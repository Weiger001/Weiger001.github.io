<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/03/25/hello-world/</url>
    <content><![CDATA[<h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h5 id="这是五级标题"><a href="#这是五级标题" class="headerlink" title="这是五级标题"></a>这是五级标题</h5><h6 id="这是六级标题"><a href="#这是六级标题" class="headerlink" title="这是六级标题"></a>这是六级标题</h6><p><strong>这是加粗的文字</strong></p>
<p><em>这是倾斜的文字</em>`</p>
<p><em><strong>这是斜体加粗的文字</strong></em></p>
<p><del>这是加删除线的文字</del></p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>这是引用的内容</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<hr>
<hr>
<hr>
<hr>
<p>![blockchain](<a href="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/">https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/</a><br>u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg “区块链”)</p>
<p><a href="http://jianshu.com/">简书</a></p>
<p><a href="http://baidu.com/">百度</a></p>
<ul>
<li>列表内容</li>
</ul>
<ul>
<li>列表内容</li>
</ul>
<ul>
<li>列表内容</li>
</ul>
<ol>
<li>列表内容</li>
<li>列表内容</li>
<li>列表内容</li>
</ol>
<table>
<thead>
<tr>
<th>姓名</th>
<th align="center">技能</th>
<th align="right">排行</th>
</tr>
</thead>
<tbody><tr>
<td>刘备</td>
<td align="center">哭</td>
<td align="right">大哥</td>
</tr>
<tr>
<td>关羽</td>
<td align="center">打</td>
<td align="right">二哥</td>
</tr>
<tr>
<td>张飞</td>
<td align="center">骂</td>
<td align="right">三弟</td>
</tr>
</tbody></table>
<p><code>create database hero;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function fun()&#123;</span><br><span class="line">     echo &quot;这是一句非常牛逼的代码&quot;;</span><br><span class="line">&#125;</span><br><span class="line">fun();</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title>2022-3-25</title>
    <url>/2022/03/25/mq/</url>
    <content><![CDATA[<h1 id="2022-3-25"><a href="#2022-3-25" class="headerlink" title="2022-3-25"></a>2022-3-25</h1><h2 id="ROCKETMQ"><a href="#ROCKETMQ" class="headerlink" title="ROCKETMQ"></a>ROCKETMQ</h2><h5 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h5><blockquote>
<p>D:\maven\rocketmq\rocketmq-all-4.3.0-bin-release\bin</p>
</blockquote>
<h3 id="具体命令"><a href="#具体命令" class="headerlink" title="具体命令"></a>具体命令</h3><ul>
<li><blockquote>
<p>start mqnamesrv.cmd</p>
</blockquote>
</li>
<li><blockquote>
<p>start mqbroker.cmd -n 127.0.0.1:9876 autoCreateTopicEnable=true</p>
</blockquote>
</li>
<li><blockquote>
<p>mqshutdown.cmd broker</p>
</blockquote>
</li>
<li><blockquote>
<p>mqshutdown.cmd namesrv</p>
</blockquote>
</li>
</ul>
<h4 id="配置修改"><a href="#配置修改" class="headerlink" title="配置修改"></a>配置修改</h4><ul>
<li><blockquote>
<p>nameSrvAddr = 127.0.0.1:9876</p>
</blockquote>
</li>
<li><blockquote>
<p>brokerIP1 = 127.0.0.1</p>
</blockquote>
</li>
</ul>
<p>修改配置后要杀死rocketmq的Broker重新启动mq服务</p>
<p>并且加上<code> -c ../conf/broker.conf</code></p>
<h3 id="可视化插件rocketmq-console"><a href="#可视化插件rocketmq-console" class="headerlink" title="可视化插件rocketmq-console"></a>可视化插件rocketmq-console</h3><h5 id="目录-1"><a href="#目录-1" class="headerlink" title="目录"></a>目录</h5><blockquote>
<p>D:\maven\rocketmq\rocketmq-externals-master\rocketmq-console</p>
</blockquote>
<h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><blockquote>
<p>D:\maven\rocketmq\rocketmq-externals-master\rocketmq-console\src\main\resources\application.properties</p>
</blockquote>
<h5 id="配置修改-1"><a href="#配置修改-1" class="headerlink" title="配置修改"></a>配置修改</h5><ul>
<li><blockquote>
<p>server.port=8066</p>
</blockquote>
</li>
<li><blockquote>
<p>rocketmq.config.namesrvAddr=127.0.0.1:9876</p>
</blockquote>
</li>
</ul>
<h4 id="运行命令"><a href="#运行命令" class="headerlink" title="运行命令"></a>运行命令</h4><p>在console目录下打包<code>mvn clean package -Dmaven.test.skip=true</code></p>
<p><strong>注</strong>windows powershell<code>mvn clean package &#39;-Dmaven.test.skip=true&#39;</code></p>
<ul>
<li><blockquote>
<p>D:\maven\rocketmq\rocketmq-externals-master\rocketmq-console\target</p>
</blockquote>
</li>
<li><blockquote>
<p>java -jar rocketmq-console-ng-1.0.1.jar</p>
</blockquote>
</li>
</ul>
<h3 id="cmd截图"><a href="#cmd截图" class="headerlink" title="cmd截图"></a>cmd截图</h3><p><img src="/img/mq_cmd.png" alt="**"></p>
<h3 id="余留问题"><a href="#余留问题" class="headerlink" title="余留问题"></a>余留问题</h3><ul>
<li>rocket的maven包没有打包到本地maven库，<del>项目中的引用实现方式未知</del></li>
<li>根据官网模拟的通讯运行似乎可以进行数据的发送和接受，但具体详情并不了解，消费者信息已经可以查询到，生产者并没有数据，<strong>发送的数据都分配到了1，3队列</strong><strong>comsumer代码</strong><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;</span><br><span class="line">import org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyContext;</span><br><span class="line">import org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyStatus;</span><br><span class="line">import org.apache.rocketmq.client.consumer.listener.MessageListenerOrderly;</span><br><span class="line">import org.apache.rocketmq.common.consumer.ConsumeFromWhere;</span><br><span class="line">import org.apache.rocketmq.common.message.MessageExt;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Random;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 顺序消息消费，带事务方式（应用可控制Offset什么时候提交）</span><br><span class="line">*/</span><br><span class="line">public class ConsumerInOrder &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(&quot;please_rename_unique_group_name_3&quot;);</span><br><span class="line">    consumer.setNamesrvAddr(&quot;127.0.0.1:9876&quot;);</span><br><span class="line">    /**</span><br><span class="line">     * 设置Consumer第一次启动是从队列头部开始消费还是队列尾部开始消费&lt;br&gt;</span><br><span class="line">     * 如果非第一次启动，那么按照上次消费的位置继续消费</span><br><span class="line">     */</span><br><span class="line">    consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line"></span><br><span class="line">    consumer.subscribe(&quot;TopicTest&quot;, &quot;TagA || TagC || TagD&quot;);</span><br><span class="line"></span><br><span class="line">    consumer.registerMessageListener(new MessageListenerOrderly() &#123;</span><br><span class="line"></span><br><span class="line">        Random random = new Random();</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public ConsumeOrderlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context) &#123;</span><br><span class="line">            context.setAutoCommit(true);</span><br><span class="line">            for (MessageExt msg : msgs) &#123;</span><br><span class="line">                // 可以看到每个queue有唯一的consume线程来消费, 订单对每个queue(分区)有序</span><br><span class="line">                System.out.println(&quot;consumeThread=&quot; + Thread.currentThread().getName() + &quot;queueId=&quot; + msg.getQueueId() + &quot;, content:&quot; + new String(msg.getBody()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                //模拟业务逻辑处理中...</span><br><span class="line">                TimeUnit.SECONDS.sleep(random.nextInt(10));</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            return ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    consumer.start();</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;Consumer Started.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li>
</ul>
<pre><code>**produce代码**
</code></pre>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    public class Producer &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    DefaultMQProducer producer = new DefaultMQProducer(&quot;please_rename_unique_group_name&quot;);</span><br><span class="line"></span><br><span class="line">    producer.setNamesrvAddr(&quot;127.0.0.1:9876&quot;);</span><br><span class="line"></span><br><span class="line">    producer.start();</span><br><span class="line"></span><br><span class="line">    String[] tags = new String[]&#123;&quot;TagA&quot;, &quot;TagC&quot;, &quot;TagD&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    // 订单列表</span><br><span class="line">    List&lt;OrderStep&gt; orderList = new Producer().buildOrders();</span><br><span class="line"></span><br><span class="line">    Date date = new Date();</span><br><span class="line">    SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">    String dateStr = sdf.format(date);</span><br><span class="line">    for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        // 加个时间前缀</span><br><span class="line">        String body = dateStr + &quot; Hello RocketMQ &quot; + orderList.get(i);</span><br><span class="line">        Message msg = new Message(&quot;TopicTest&quot;, tags[i % tags.length], &quot;KEY&quot; + i, body.getBytes());</span><br><span class="line"></span><br><span class="line">        SendResult sendResult = producer.send(msg, new MessageQueueSelector() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public MessageQueue select(List&lt;MessageQueue&gt; mqs, Message msg, Object arg) &#123;</span><br><span class="line">                Long id = (Long) arg;  //根据订单id选择发送queue</span><br><span class="line">                long index = id % mqs.size();</span><br><span class="line">                return mqs.get((int) index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, orderList.get(i).getOrderId());//订单id</span><br><span class="line"></span><br><span class="line">        System.out.println(String.format(&quot;SendResult status:%s, queueId:%d, body:%s&quot;,</span><br><span class="line">                sendResult.getSendStatus(),</span><br><span class="line">                sendResult.getMessageQueue().getQueueId(),</span><br><span class="line">                body));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    producer.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 订单的步骤</span><br><span class="line"> */</span><br><span class="line">private static class OrderStep &#123;</span><br><span class="line">    private long orderId;</span><br><span class="line">    private String desc;</span><br><span class="line"></span><br><span class="line">    public long getOrderId() &#123;</span><br><span class="line">        return orderId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setOrderId(long orderId) &#123;</span><br><span class="line">        this.orderId = orderId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDesc() &#123;</span><br><span class="line">        return desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDesc(String desc) &#123;</span><br><span class="line">        this.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;OrderStep&#123;&quot; +</span><br><span class="line">                &quot;orderId=&quot; + orderId +</span><br><span class="line">                &quot;, desc=&#x27;&quot; + desc + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 生成模拟订单数据</span><br><span class="line"> */</span><br><span class="line">private List&lt;OrderStep&gt; buildOrders() &#123;</span><br><span class="line">    List&lt;OrderStep&gt; orderList = new ArrayList&lt;OrderStep&gt;();</span><br><span class="line"></span><br><span class="line">    OrderStep orderDemo = new OrderStep();</span><br><span class="line">    orderDemo.setOrderId(15103111039L);</span><br><span class="line">    orderDemo.setDesc(&quot;创建&quot;);</span><br><span class="line">    orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">    orderDemo = new OrderStep();</span><br><span class="line">    orderDemo.setOrderId(15103111065L);</span><br><span class="line">    orderDemo.setDesc(&quot;创建&quot;);</span><br><span class="line">    orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">    orderDemo = new OrderStep();</span><br><span class="line">    orderDemo.setOrderId(15103111039L);</span><br><span class="line">    orderDemo.setDesc(&quot;付款&quot;);</span><br><span class="line">    orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">    orderDemo = new OrderStep();</span><br><span class="line">    orderDemo.setOrderId(15103117235L);</span><br><span class="line">    orderDemo.setDesc(&quot;创建&quot;);</span><br><span class="line">    orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">    orderDemo = new OrderStep();</span><br><span class="line">    orderDemo.setOrderId(15103111065L);</span><br><span class="line">    orderDemo.setDesc(&quot;付款&quot;);</span><br><span class="line">    orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">    orderDemo = new OrderStep();</span><br><span class="line">    orderDemo.setOrderId(15103117235L);</span><br><span class="line">    orderDemo.setDesc(&quot;付款&quot;);</span><br><span class="line">    orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">    orderDemo = new OrderStep();</span><br><span class="line">    orderDemo.setOrderId(15103111065L);</span><br><span class="line">    orderDemo.setDesc(&quot;完成&quot;);</span><br><span class="line">    orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">    orderDemo = new OrderStep();</span><br><span class="line">    orderDemo.setOrderId(15103111039L);</span><br><span class="line">    orderDemo.setDesc(&quot;推送&quot;);</span><br><span class="line">    orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">    orderDemo = new OrderStep();</span><br><span class="line">    orderDemo.setOrderId(15103117235L);</span><br><span class="line">    orderDemo.setDesc(&quot;完成&quot;);</span><br><span class="line">    orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">    orderDemo = new OrderStep();</span><br><span class="line">    orderDemo.setOrderId(15103111039L);</span><br><span class="line">    orderDemo.setDesc(&quot;完成&quot;);</span><br><span class="line">    orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">    return orderList;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><del>可视化的rocketmq插件没有配置成功，接收不到生产和接受的信息数据</del></li>
<li><del>版本混乱，本地已配置mq，项目中导入的似乎不是本地的mq，配置混乱</del></li>
<li>项目中引用的dependcy依赖只是java rocketmq库，运行还是依赖于本地的rocketmq环境</li>
</ul>
<h2 id="尾气平台"><a href="#尾气平台" class="headerlink" title="尾气平台"></a>尾气平台</h2><ul>
<li>1.SCR上游/下游NOX图表</li>
<li>2.SCR入口/出口温度图表</li>
<li>3.DPF压差图表</li>
<li>4.EGR阀开度对比</li>
</ul>
<p>四个功能在同一个接口实现，没有对数据进行编号筛选，只进行了对时间的筛选,startTime,endTime。</p>
<h2 id="电池管理平台"><a href="#电池管理平台" class="headerlink" title="电池管理平台"></a>电池管理平台</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><h4 id="customFooTable"><a href="#customFooTable" class="headerlink" title="customFooTable"></a>customFooTable</h4><blockquote>
<p>customFooTable调用的接口返回类型得是Corepage类型，得到corepae类型表格会自动填充,dao层调用findbyHql(Corepage,String),并且返回的字段要和table的字段名称相同</p>
</blockquote>
<h4 id="输入框向后台传入参数"><a href="#输入框向后台传入参数" class="headerlink" title="输入框向后台传入参数"></a>输入框向后台传入参数</h4><blockquote>
<p>input输入框不输入值会默认传””，<strong>而不是null</strong>，option选择默认值不设定value传给后台的就是null</p>
</blockquote>
]]></content>
      <tags>
        <tag>ROCKETMQ</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>2022-3-28</title>
    <url>/2022/03/28/mq2/</url>
    <content><![CDATA[<h1 id="2022-3-28"><a href="#2022-3-28" class="headerlink" title="2022-3-28"></a>2022-3-28</h1><h2 id="ROCKETMQ"><a href="#ROCKETMQ" class="headerlink" title="ROCKETMQ"></a>ROCKETMQ</h2><h4 id="配置修改"><a href="#配置修改" class="headerlink" title="配置修改"></a>配置修改</h4><ul>
<li><blockquote>
<p>nameSrvAddr = 150.158.141.106:9876</p>
</blockquote>
</li>
<li><blockquote>
<p>brokerIP1 = 150.158.141.106</p>
</blockquote>
</li>
</ul>
<h3 id="具体命令"><a href="#具体命令" class="headerlink" title="具体命令"></a>具体命令</h3><ul>
<li><blockquote>
<p>start mqnamesrv.cmd</p>
</blockquote>
</li>
<li><blockquote>
<p>start mqbroker.cmd -n 150.158.141.106:9876 autoCreateTopicEnable=true</p>
</blockquote>
</li>
<li><blockquote>
<p>start mqbroker.cmd -n 150.158.141.106:9876 -c ../conf/broker.conf</p>
</blockquote>
</li>
<li><blockquote>
<p>mqshutdown.cmd broker</p>
</blockquote>
</li>
<li><blockquote>
<p>mqshutdown.cmd namesrv</p>
</blockquote>
</li>
<li><blockquote>
<p>mqadmin topicList -n 150.158.141.106:9876</p>
</blockquote>
</li>
</ul>
<p>报错<code>connect to &lt;NULL&gt; failed</code>，不知道是哪里的配置有问题，奇怪的报错</p>
<p>有一个看着看不懂的回答<code>这是网络Ip的问题哈，docker 启动 rocket mq的namser server之后，是一个vip，而broker 呢需要连接真实的ip，真实的生产环境中完全都是宿主机来部署的，不可能集成到容器中 </code></p>
<p><code>NettyRemotingClient在channel出现问题的时候会抛出RemotingConnectException</code>这是抛出的异常解析，关键并不理解channel</p>
<p>实在没得进度最后附上<a href="https://blog.csdn.net/tales522/article/details/88094446">rocketmq常用cmd操作</a></p>
<p>还是回头补一句环境真搞人，一天下来本地没改最后快下班就成功了，真的是莫名其妙的浪费了一天时间，报锤子错</p>
]]></content>
      <tags>
        <tag>ROCKETMQ</tag>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title>2022-3-30</title>
    <url>/2022/03/30/2022-3-30/</url>
    <content><![CDATA[<h1 id="2022-3-30"><a href="#2022-3-30" class="headerlink" title="2022-3-30"></a>2022-3-30</h1><h2 id="Jacob"><a href="#Jacob" class="headerlink" title="Jacob"></a>Jacob</h2><p>之前写数据库文档写的一个小demo，昨天使用突然忘记了一些配置，好记性不如烂笔头</p>
<ol>
<li>本地解压jacob</li>
<li>jacob-1.20-x64.dll放在sys32中</li>
<li>项目中导入jacob的包<img src="/pic/idea_jacob.png" alt="*"></li>
</ol>
<p><code>word.openDocument(path)</code>打开本地word文件，目前只支持对已有表格的扩充</p>
<p><img src="/pic/sql_doc.png" alt="*"></p>
<p>由于表格格式，表格前几行和后面是分开处理，表名英文是直接写入，从第六行后面扩充数据库字段，也就是说文档需要初始化表格6-7行，最好7行。</p>
<h4 id="文档初始化"><a href="#文档初始化" class="headerlink" title="文档初始化"></a>文档初始化</h4><p>初始文档需要有和数据库表数量的同等数量表格，并且是需要开头的变更记录表格，<strong>因为填充是从word文档第二张开始的</strong>，<code>// 循环获取表格 for(int i=2;i&lt;=tablesCount;i++)</code>。</p>
<h4 id="文档填充"><a href="#文档填充" class="headerlink" title="文档填充"></a>文档填充</h4><p>目前的填充方案就是字段和对应的类型和长度直接从数据库提取，中文字段名和说明共同是数据库中的注释部分，想着进一步对数据库的注释做补全，例如再中文字段名和说明之间加上符号，例如 <code>状态||0正确，1错误</code>这种，我这边拿到再分割处理一下又省事了一点，<strong>但处于某种不可抗力因素暂时耽搁</strong>。</p>
<h3 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h3><ul>
<li>查询数据库时候可以查询到服务器所有数据的表，导致运行需要大量的时间并且需要我手动的去进行去重，问题是由</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static List&lt;String&gt; getTableNames() &#123;</span><br><span class="line">    List&lt;String&gt; tableNames = new ArrayList&lt;&gt;();</span><br><span class="line">    Connection conn = getConnection();</span><br><span class="line">    ResultSet rs = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        //获取数据库的元数据</span><br><span class="line">        DatabaseMetaData db = conn.getMetaData();</span><br><span class="line"></span><br><span class="line">        //从元数据中获取到所有的表名</span><br><span class="line">        rs = db.getTables(null, null, null, new String[] &#123; &quot;TABLE&quot; &#125;);</span><br><span class="line">        while(rs.next()) &#123;</span><br><span class="line">            tableNames.add(rs.getString(3));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (SQLException e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            rs.close();</span><br><span class="line">            closeConnection(conn);</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return tableNames;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这一部分导致，感觉问题出再获取数据库的元数据，但是不知道具体原因暂时搁置（<del>能跑就行</del>）</p>
<ul>
<li><p>还有就是tinyint类型读取出来是bit,这个也不太理解，但是我手动改成了tinyint（<del>能跑就行</del>）</p>
</li>
<li><p>最后问题是最难缠的，再读取int类型长度的时候读取不出来，所有的int长度都是10（<del>好像是</del>），只能去进行手动修改，这个问题比较烦人，而且感觉没什么头绪，所有暂时搁置，等待进一步研究修改。</p>
</li>
</ul>
<h3 id="小说明"><a href="#小说明" class="headerlink" title="小说明"></a>小说明</h3><p>不是个什么好东西，勉勉强强凑合着用吧，总比CV好。</p>
<h2 id="RokcetMQ"><a href="#RokcetMQ" class="headerlink" title="RokcetMQ"></a>RokcetMQ</h2><p>包装成了一个task的任务<code>extends Thread implements ApplicationListener&lt;ContextRefreshedEvent&gt;</code><br>继承Thread线程和实现一个监听的接口</p>
<h3 id="遗留问题-1"><a href="#遗留问题-1" class="headerlink" title="遗留问题"></a>遗留问题</h3><ul>
<li>consumer一直在实例化，感觉这个问题不是很大，而且抛出异常的时候consumer设置为null也需要重新初始化，在方法里面的实例化对象应该只存活在方法里，<strong>方法里对象的生命周期</strong>。</li>
<li>consumer也一直在start,感觉这个可能会产生一定的冲突，start也是一个线程运行，这样多次启动不同的start，感觉可能会有冲突</li>
<li>综上所述，需要的应该是一个单个不断接受消息的consumer，抛出异常的时候再去进行初始化。</li>
</ul>
]]></content>
      <tags>
        <tag>ROCKETMQ</tag>
        <tag>MQ</tag>
        <tag>文档</tag>
        <tag>jacob</tag>
      </tags>
  </entry>
</search>
